sort of a TIL area / for personal notes  
- day 1b have to calculate offset from collision coordinates  
- I suspect the getBearing function used for day 1 can be further reduced / mathed, but I'll work that out on another day  
- as per discussion with my friend, another way to solve day 1b will be probably exploiting the fact that the lines can only intersect in so many ways since it's only horizontal / vertical. for the general case of line intersection apparently line sweep is the way to go.  
- I know there are linear algebra / matrices libraries out there for golang, [this](https://github.com/gonum/matrix) actually seems like a pretty decent one, but I'm trying to stick to the standard library if possible.  
- in a package, if a function is defined somewhere, even when uncapitalized, it cannot be defined elsewhere in the package, it just isn't being exported for public(??) use   
- so strconv.FormatInt(i, 10) is used for converting int64 since strconv.Atoi only works on int types  
- apparently variables in structs have to be capitalized or they won't be exported  
- yes I'm aware that my DRY (+ SE in general) principles here are horrible, that's what happens when you try to write in semi comp prog form  
- you used regular expressions: now you have 2 problems. day 7 was tricky because I did a regex replace of anything between square brackets, but did not consider that I'm effectively concatenating the 2 ends in between, introducing some false positives  
- probably is a better array rotation algorithm around, if I did more leetcode etc I may actually know one  
- day 8 was a nightmare because I kept mixing up my variables for rows and cols. Random thought : maybe for such problems in future it will be easier to flatten the array and just do a (width * y + x)  
- My answer for 9b really should have been wrong due to integer overflow but somehow golang has a way of circumventing that.  
- Day 10 is clearly a graph problem  
- I used bash for day 10. ```grep -o "bot [0-9]\+" 10.txt | awk '{print $2}' | sort -nr | head -n 1```
- Day 10 : need concept of active bots (ie. those that currently hold 2). this can either be done by iterating through entire graph at each epoch, or maintaining a set somehow  
- Day 11 is another graph problem (or at least can be modelled as so), specifically some variation of a river crossing puzzle. Also possibly may be solved via DP.  
- so for day 14 I have this solution in scala that works for part a, but takes forever to run for part b. bottleneck seems to be the 2016 * md5, so I shall see if I can hack up a solution in another language  
- Day 15 apparently is this thing called Chinese Remainder Theorem. I knew straight up from seeing the question that some form of modular arithmetic is involved, but didn't know exactly what to do  
- Day 20 seems like it can be done using interval trees, which I haven't written one myself yet. Also reminds me of some usaco problem from long long ago, I may revisit that in future  
